/* Generated by re2c 3.1 */
// -*-c-*-
#include "arith.lexer.h"
#include <assert.h>
// Definitions first
  

static lexer_match_t arith_match_PLUS(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case 'a': goto re2c3;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c7;
      goto re2c1;
  }
re2c1:
  ++YYCURSOR;
re2c2:
  { goto failure; }
re2c3:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'd': goto re2c4;
    default: goto re2c2;
  }
re2c4:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'd': goto re2c6;
    default: goto re2c5;
  }
re2c5:
  YYCURSOR = YYMARKER;
  goto re2c2;
re2c6:
  ++YYCURSOR;
  { id = arith_token_PLUS; goto match; }
re2c7:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_MINUS(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case 's': goto re2c11;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c15;
      goto re2c9;
  }
re2c9:
  ++YYCURSOR;
re2c10:
  { goto failure; }
re2c11:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'u': goto re2c12;
    default: goto re2c10;
  }
re2c12:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'b': goto re2c14;
    default: goto re2c13;
  }
re2c13:
  YYCURSOR = YYMARKER;
  goto re2c10;
re2c14:
  ++YYCURSOR;
  { id = arith_token_MINUS; goto match; }
re2c15:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_TIMES(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case 'm': goto re2c19;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c23;
      goto re2c17;
  }
re2c17:
  ++YYCURSOR;
re2c18:
  { goto failure; }
re2c19:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'u': goto re2c20;
    default: goto re2c18;
  }
re2c20:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'l': goto re2c22;
    default: goto re2c21;
  }
re2c21:
  YYCURSOR = YYMARKER;
  goto re2c18;
re2c22:
  ++YYCURSOR;
  { id = arith_token_TIMES; goto match; }
re2c23:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_DIVIDE(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case 'd': goto re2c27;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c31;
      goto re2c25;
  }
re2c25:
  ++YYCURSOR;
re2c26:
  { goto failure; }
re2c27:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'i': goto re2c28;
    default: goto re2c26;
  }
re2c28:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'v': goto re2c30;
    default: goto re2c29;
  }
re2c29:
  YYCURSOR = YYMARKER;
  goto re2c26;
re2c30:
  ++YYCURSOR;
  { id = arith_token_DIVIDE; goto match; }
re2c31:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_REMAINDER(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case 'r': goto re2c35;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c39;
      goto re2c33;
  }
re2c33:
  ++YYCURSOR;
re2c34:
  { goto failure; }
re2c35:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'e': goto re2c36;
    default: goto re2c34;
  }
re2c36:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'm': goto re2c38;
    default: goto re2c37;
  }
re2c37:
  YYCURSOR = YYMARKER;
  goto re2c34;
re2c38:
  ++YYCURSOR;
  { id = arith_token_REMAINDER; goto match; }
re2c39:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_ASH(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case 'a': goto re2c43;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c47;
      goto re2c41;
  }
re2c41:
  ++YYCURSOR;
re2c42:
  { goto failure; }
re2c43:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 's': goto re2c44;
    default: goto re2c42;
  }
re2c44:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'h': goto re2c46;
    default: goto re2c45;
  }
re2c45:
  YYCURSOR = YYMARKER;
  goto re2c42;
re2c46:
  ++YYCURSOR;
  { id = arith_token_ASH; goto match; }
re2c47:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_LSH(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case 'l': goto re2c51;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c55;
      goto re2c49;
  }
re2c49:
  ++YYCURSOR;
re2c50:
  { goto failure; }
re2c51:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 's': goto re2c52;
    default: goto re2c50;
  }
re2c52:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'h': goto re2c54;
    default: goto re2c53;
  }
re2c53:
  YYCURSOR = YYMARKER;
  goto re2c50;
re2c54:
  ++YYCURSOR;
  { id = arith_token_LSH; goto match; }
re2c55:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_RSH(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case 'r': goto re2c59;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c63;
      goto re2c57;
  }
re2c57:
  ++YYCURSOR;
re2c58:
  { goto failure; }
re2c59:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 's': goto re2c60;
    default: goto re2c58;
  }
re2c60:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'h': goto re2c62;
    default: goto re2c61;
  }
re2c61:
  YYCURSOR = YYMARKER;
  goto re2c58;
re2c62:
  ++YYCURSOR;
  { id = arith_token_RSH; goto match; }
re2c63:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_BITNOT(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case 'n': goto re2c67;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c71;
      goto re2c65;
  }
re2c65:
  ++YYCURSOR;
re2c66:
  { goto failure; }
re2c67:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'o': goto re2c68;
    default: goto re2c66;
  }
re2c68:
  yych = *++YYCURSOR;
  switch (yych) {
    case 't': goto re2c70;
    default: goto re2c69;
  }
re2c69:
  YYCURSOR = YYMARKER;
  goto re2c66;
re2c70:
  ++YYCURSOR;
  { id = arith_token_BITNOT; goto match; }
re2c71:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_BITOR(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case 'o': goto re2c75;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c77;
      goto re2c73;
  }
re2c73:
  ++YYCURSOR;
re2c74:
  { goto failure; }
re2c75:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'r': goto re2c76;
    default: goto re2c74;
  }
re2c76:
  ++YYCURSOR;
  { id = arith_token_BITOR; goto match; }
re2c77:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_BITAND(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case 'a': goto re2c81;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c85;
      goto re2c79;
  }
re2c79:
  ++YYCURSOR;
re2c80:
  { goto failure; }
re2c81:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'n': goto re2c82;
    default: goto re2c80;
  }
re2c82:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'd': goto re2c84;
    default: goto re2c83;
  }
re2c83:
  YYCURSOR = YYMARKER;
  goto re2c80;
re2c84:
  ++YYCURSOR;
  { id = arith_token_BITAND; goto match; }
re2c85:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_BITXOR(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case 'x': goto re2c89;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c93;
      goto re2c87;
  }
re2c87:
  ++YYCURSOR;
re2c88:
  { goto failure; }
re2c89:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'o': goto re2c90;
    default: goto re2c88;
  }
re2c90:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'r': goto re2c92;
    default: goto re2c91;
  }
re2c91:
  YYCURSOR = YYMARKER;
  goto re2c88;
re2c92:
  ++YYCURSOR;
  { id = arith_token_BITXOR; goto match; }
re2c93:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_CMP(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case 'c': goto re2c97;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c101;
      goto re2c95;
  }
re2c95:
  ++YYCURSOR;
re2c96:
  { goto failure; }
re2c97:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'm': goto re2c98;
    default: goto re2c96;
  }
re2c98:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'p': goto re2c100;
    default: goto re2c99;
  }
re2c99:
  YYCURSOR = YYMARKER;
  goto re2c96;
re2c100:
  ++YYCURSOR;
  { id = arith_token_CMP; goto match; }
re2c101:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_ABSOLUTE(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case 'a': goto re2c105;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c109;
      goto re2c103;
  }
re2c103:
  ++YYCURSOR;
re2c104:
  { goto failure; }
re2c105:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'b': goto re2c106;
    default: goto re2c104;
  }
re2c106:
  yych = *++YYCURSOR;
  switch (yych) {
    case 's': goto re2c108;
    default: goto re2c107;
  }
re2c107:
  YYCURSOR = YYMARKER;
  goto re2c104;
re2c108:
  ++YYCURSOR;
  { id = arith_token_ABSOLUTE; goto match; }
re2c109:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_NEGATE(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case 'n': goto re2c113;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c117;
      goto re2c111;
  }
re2c111:
  ++YYCURSOR;
re2c112:
  { goto failure; }
re2c113:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'e': goto re2c114;
    default: goto re2c112;
  }
re2c114:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'g': goto re2c116;
    default: goto re2c115;
  }
re2c115:
  YYCURSOR = YYMARKER;
  goto re2c112;
re2c116:
  ++YYCURSOR;
  { id = arith_token_NEGATE; goto match; }
re2c117:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_INCREMENT(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case 'i': goto re2c121;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c126;
      goto re2c119;
  }
re2c119:
  ++YYCURSOR;
re2c120:
  { goto failure; }
re2c121:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'n': goto re2c122;
    default: goto re2c120;
  }
re2c122:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'c': goto re2c124;
    default: goto re2c123;
  }
re2c123:
  YYCURSOR = YYMARKER;
  goto re2c120;
re2c124:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'r': goto re2c125;
    default: goto re2c123;
  }
re2c125:
  ++YYCURSOR;
  { id = arith_token_INCREMENT; goto match; }
re2c126:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_DECREMENT(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case 'd': goto re2c130;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c135;
      goto re2c128;
  }
re2c128:
  ++YYCURSOR;
re2c129:
  { goto failure; }
re2c130:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'e': goto re2c131;
    default: goto re2c129;
  }
re2c131:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'c': goto re2c133;
    default: goto re2c132;
  }
re2c132:
  YYCURSOR = YYMARKER;
  goto re2c129;
re2c133:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'r': goto re2c134;
    default: goto re2c132;
  }
re2c134:
  ++YYCURSOR;
  { id = arith_token_DECREMENT; goto match; }
re2c135:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_INTEGER(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case '-': goto re2c139;
    case '0': goto re2c140;
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9': goto re2c142;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c143;
      goto re2c137;
  }
re2c137:
  ++YYCURSOR;
re2c138:
  { goto failure; }
re2c139:
  yych = *++YYCURSOR;
  switch (yych) {
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9': goto re2c142;
    default: goto re2c138;
  }
re2c140:
  ++YYCURSOR;
re2c141:
  { id = arith_token_INTEGER; goto match; }
re2c142:
  yych = *++YYCURSOR;
  switch (yych) {
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9': goto re2c142;
    default: goto re2c141;
  }
re2c143:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_SPACE(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case '\t':
    case '\v':
    case '\f':
    case '\r':
    case ' ': goto re2c146;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c148;
      goto re2c145;
  }
re2c145:
  ++YYCURSOR;
  { goto failure; }
re2c146:
  yych = *++YYCURSOR;
  switch (yych) {
    case '\t':
    case '\v':
    case '\f':
    case '\r':
    case ' ': goto re2c146;
    default: goto re2c147;
  }
re2c147:
  { id = arith_token_SPACE; goto match; }
re2c148:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_NEWLINE(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  unsigned int yyaccept = 0;
  yych = *YYCURSOR;
  switch (yych) {
    case '\t':
    case '\v':
    case '\f':
    case '\r':
    case ' ': goto re2c152;
    case '\n': goto re2c153;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c158;
      goto re2c150;
  }
re2c150:
  ++YYCURSOR;
re2c151:
  { goto failure; }
re2c152:
  yyaccept = 0;
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case '\t':
    case '\n':
    case '\v':
    case '\f':
    case '\r':
    case ' ': goto re2c156;
    default: goto re2c151;
  }
re2c153:
  yyaccept = 1;
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case '\t':
    case '\v':
    case '\f':
    case '\r':
    case ' ': goto re2c155;
    case '\n': goto re2c153;
    default: goto re2c154;
  }
re2c154:
  { id = arith_token_NEWLINE; goto match; }
re2c155:
  yych = *++YYCURSOR;
re2c156:
  switch (yych) {
    case '\t':
    case '\v':
    case '\f':
    case '\r':
    case ' ': goto re2c155;
    case '\n': goto re2c153;
    default: goto re2c157;
  }
re2c157:
  YYCURSOR = YYMARKER;
  if (yyaccept == 0) {
    goto re2c151;
  } else {
    goto re2c154;
  }
re2c158:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_CONTROL(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case '!':
    case '#':
    case '$':
    case '%':
    case '&':
    case '@':
    case 'A':
    case 'B':
    case 'C':
    case 'D':
    case 'E':
    case 'F':
    case 'G':
    case 'H':
    case 'I':
    case 'J':
    case 'K':
    case 'L':
    case 'M':
    case 'N':
    case 'O':
    case 'P':
    case 'Q':
    case 'R':
    case 'S':
    case 'T':
    case 'U':
    case 'V':
    case 'W':
    case 'X':
    case 'Y':
    case 'Z': goto re2c161;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c163;
      goto re2c160;
  }
re2c160:
  ++YYCURSOR;
  { goto failure; }
re2c161:
  yych = *++YYCURSOR;
  switch (yych) {
    case '!':
    case '#':
    case '$':
    case '%':
    case '&':
    case '@':
    case 'A':
    case 'B':
    case 'C':
    case 'D':
    case 'E':
    case 'F':
    case 'G':
    case 'H':
    case 'I':
    case 'J':
    case 'K':
    case 'L':
    case 'M':
    case 'N':
    case 'O':
    case 'P':
    case 'Q':
    case 'R':
    case 'S':
    case 'T':
    case 'U':
    case 'V':
    case 'W':
    case 'X':
    case 'Y':
    case 'Z': goto re2c161;
    default: goto re2c162;
  }
re2c162:
  { id = arith_token_CONTROL; goto match; }
re2c163:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}


lexer_match_t arith_lexer_re2c_sequence_regex_bytes_matching(lexer_t lex,
                                             lexer_iterator_t iter)
{
  (void)lex;
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;

  
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  unsigned int yyaccept = 0;
  yych = *YYCURSOR;
  switch (yych) {
    case '\t':
    case '\v':
    case '\f':
    case '\r':
    case ' ': goto re2c167;
    case '\n': goto re2c169;
    case '!':
    case '#':
    case '$':
    case '%':
    case '&':
    case '@':
    case 'A':
    case 'B':
    case 'C':
    case 'D':
    case 'E':
    case 'F':
    case 'G':
    case 'H':
    case 'I':
    case 'J':
    case 'K':
    case 'L':
    case 'M':
    case 'N':
    case 'O':
    case 'P':
    case 'Q':
    case 'R':
    case 'S':
    case 'T':
    case 'U':
    case 'V':
    case 'W':
    case 'X':
    case 'Y':
    case 'Z': goto re2c171;
    case '-': goto re2c173;
    case '0': goto re2c174;
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9': goto re2c176;
    case 'a': goto re2c177;
    case 'c': goto re2c178;
    case 'd': goto re2c179;
    case 'i': goto re2c180;
    case 'l': goto re2c181;
    case 'm': goto re2c182;
    case 'n': goto re2c183;
    case 'o': goto re2c184;
    case 'r': goto re2c185;
    case 's': goto re2c186;
    case 'x': goto re2c187;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c225;
      goto re2c165;
  }
re2c165:
  ++YYCURSOR;
re2c166:
  { id = arith_token_UNKNOWN; goto match; }
re2c167:
  yych = *++YYCURSOR;
  switch (yych) {
    case '\t':
    case '\v':
    case '\f':
    case '\r':
    case ' ': goto re2c167;
    case '\n': goto re2c169;
    default: goto re2c168;
  }
re2c168:
  { id = arith_token_SPACE; goto match; }
re2c169:
  yyaccept = 0;
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case '\t':
    case '\v':
    case '\f':
    case '\r':
    case ' ': goto re2c188;
    case '\n': goto re2c169;
    default: goto re2c170;
  }
re2c170:
  { id = arith_token_NEWLINE; goto match; }
re2c171:
  yych = *++YYCURSOR;
  switch (yych) {
    case '!':
    case '#':
    case '$':
    case '%':
    case '&':
    case '@':
    case 'A':
    case 'B':
    case 'C':
    case 'D':
    case 'E':
    case 'F':
    case 'G':
    case 'H':
    case 'I':
    case 'J':
    case 'K':
    case 'L':
    case 'M':
    case 'N':
    case 'O':
    case 'P':
    case 'Q':
    case 'R':
    case 'S':
    case 'T':
    case 'U':
    case 'V':
    case 'W':
    case 'X':
    case 'Y':
    case 'Z': goto re2c171;
    default: goto re2c172;
  }
re2c172:
  { id = arith_token_CONTROL; goto match; }
re2c173:
  yych = *++YYCURSOR;
  switch (yych) {
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9': goto re2c176;
    default: goto re2c166;
  }
re2c174:
  ++YYCURSOR;
re2c175:
  { id = arith_token_INTEGER; goto match; }
re2c176:
  yych = *++YYCURSOR;
  switch (yych) {
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9': goto re2c176;
    default: goto re2c175;
  }
re2c177:
  yyaccept = 1;
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'b': goto re2c190;
    case 'd': goto re2c191;
    case 'n': goto re2c192;
    case 's': goto re2c193;
    default: goto re2c166;
  }
re2c178:
  yyaccept = 1;
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'm': goto re2c194;
    default: goto re2c166;
  }
re2c179:
  yyaccept = 1;
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'e': goto re2c195;
    case 'i': goto re2c196;
    default: goto re2c166;
  }
re2c180:
  yyaccept = 1;
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'n': goto re2c197;
    default: goto re2c166;
  }
re2c181:
  yyaccept = 1;
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 's': goto re2c198;
    default: goto re2c166;
  }
re2c182:
  yyaccept = 1;
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'u': goto re2c199;
    default: goto re2c166;
  }
re2c183:
  yyaccept = 1;
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'e': goto re2c200;
    case 'o': goto re2c201;
    default: goto re2c166;
  }
re2c184:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'r': goto re2c202;
    default: goto re2c166;
  }
re2c185:
  yyaccept = 1;
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'e': goto re2c203;
    case 's': goto re2c204;
    default: goto re2c166;
  }
re2c186:
  yyaccept = 1;
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'u': goto re2c205;
    default: goto re2c166;
  }
re2c187:
  yyaccept = 1;
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'o': goto re2c206;
    default: goto re2c166;
  }
re2c188:
  yych = *++YYCURSOR;
  switch (yych) {
    case '\t':
    case '\v':
    case '\f':
    case '\r':
    case ' ': goto re2c188;
    case '\n': goto re2c169;
    default: goto re2c189;
  }
re2c189:
  YYCURSOR = YYMARKER;
  if (yyaccept == 0) {
    goto re2c170;
  } else {
    goto re2c166;
  }
re2c190:
  yych = *++YYCURSOR;
  switch (yych) {
    case 's': goto re2c207;
    default: goto re2c189;
  }
re2c191:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'd': goto re2c208;
    default: goto re2c189;
  }
re2c192:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'd': goto re2c209;
    default: goto re2c189;
  }
re2c193:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'h': goto re2c210;
    default: goto re2c189;
  }
re2c194:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'p': goto re2c211;
    default: goto re2c189;
  }
re2c195:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'c': goto re2c212;
    default: goto re2c189;
  }
re2c196:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'v': goto re2c213;
    default: goto re2c189;
  }
re2c197:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'c': goto re2c214;
    default: goto re2c189;
  }
re2c198:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'h': goto re2c215;
    default: goto re2c189;
  }
re2c199:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'l': goto re2c216;
    default: goto re2c189;
  }
re2c200:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'g': goto re2c217;
    default: goto re2c189;
  }
re2c201:
  yych = *++YYCURSOR;
  switch (yych) {
    case 't': goto re2c218;
    default: goto re2c189;
  }
re2c202:
  ++YYCURSOR;
  { id = arith_token_BITOR; goto match; }
re2c203:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'm': goto re2c219;
    default: goto re2c189;
  }
re2c204:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'h': goto re2c220;
    default: goto re2c189;
  }
re2c205:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'b': goto re2c221;
    default: goto re2c189;
  }
re2c206:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'r': goto re2c222;
    default: goto re2c189;
  }
re2c207:
  ++YYCURSOR;
  { id = arith_token_ABSOLUTE; goto match; }
re2c208:
  ++YYCURSOR;
  { id = arith_token_PLUS; goto match; }
re2c209:
  ++YYCURSOR;
  { id = arith_token_BITAND; goto match; }
re2c210:
  ++YYCURSOR;
  { id = arith_token_ASH; goto match; }
re2c211:
  ++YYCURSOR;
  { id = arith_token_CMP; goto match; }
re2c212:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'r': goto re2c223;
    default: goto re2c189;
  }
re2c213:
  ++YYCURSOR;
  { id = arith_token_DIVIDE; goto match; }
re2c214:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'r': goto re2c224;
    default: goto re2c189;
  }
re2c215:
  ++YYCURSOR;
  { id = arith_token_LSH; goto match; }
re2c216:
  ++YYCURSOR;
  { id = arith_token_TIMES; goto match; }
re2c217:
  ++YYCURSOR;
  { id = arith_token_NEGATE; goto match; }
re2c218:
  ++YYCURSOR;
  { id = arith_token_BITNOT; goto match; }
re2c219:
  ++YYCURSOR;
  { id = arith_token_REMAINDER; goto match; }
re2c220:
  ++YYCURSOR;
  { id = arith_token_RSH; goto match; }
re2c221:
  ++YYCURSOR;
  { id = arith_token_MINUS; goto match; }
re2c222:
  ++YYCURSOR;
  { id = arith_token_BITXOR; goto match; }
re2c223:
  ++YYCURSOR;
  { id = arith_token_DECREMENT; goto match; }
re2c224:
  ++YYCURSOR;
  { id = arith_token_INCREMENT; goto match; }
re2c225:
  { goto failure; }
}

  // re2c finish

  

  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:
  assert(id == arith_token_count);
  id = arith_token_UNKNOWN;
  YYCURSOR = iter.cursor;

match:;
  size_t width = YYCURSOR - iter.cursor;
  return (lexer_match_t){
      .regex_id = (size_t)id,
      .bytes_count = width,
  };
}


lexer_token_t arith_lexer_re2c_iterator_step(lexer_t lex,
                                             lexer_iterator_t *iter)
{
  lexer_match_t res = arith_lexer_re2c_sequence_regex_bytes_matching(lex, *iter);
  lexer_token_t result = {
    .id = res.regex_id,
    .value = iter->cursor,
    .width = res.bytes_count,
  };
  iter->cursor += res.bytes_count;
  return result;
}


lexer_match_t arith_lexer_re2c_single_regex_bytes_matching(lexer_t l, size_t regex_idx, lexer_iterator_t iter)
{
  lexer_match_t failure = (lexer_match_t) { .regex_id = arith_token_count, .bytes_count = 0, };
  if (lexer_iterator_t_empty(iter))
  {
    return failure;
  }
  switch(regex_idx)
  {
    case arith_token_UNKNOWN: return (lexer_match_t) { .regex_id = arith_token_UNKNOWN, .bytes_count = 1,}; 
    case arith_token_PLUS: return arith_match_PLUS(l, iter);
    case arith_token_MINUS: return arith_match_MINUS(l, iter);
    case arith_token_TIMES: return arith_match_TIMES(l, iter);
    case arith_token_DIVIDE: return arith_match_DIVIDE(l, iter);
    case arith_token_REMAINDER: return arith_match_REMAINDER(l, iter);
    case arith_token_ASH: return arith_match_ASH(l, iter);
    case arith_token_LSH: return arith_match_LSH(l, iter);
    case arith_token_RSH: return arith_match_RSH(l, iter);
    case arith_token_BITNOT: return arith_match_BITNOT(l, iter);
    case arith_token_BITOR: return arith_match_BITOR(l, iter);
    case arith_token_BITAND: return arith_match_BITAND(l, iter);
    case arith_token_BITXOR: return arith_match_BITXOR(l, iter);
    case arith_token_CMP: return arith_match_CMP(l, iter);
    case arith_token_ABSOLUTE: return arith_match_ABSOLUTE(l, iter);
    case arith_token_NEGATE: return arith_match_NEGATE(l, iter);
    case arith_token_INCREMENT: return arith_match_INCREMENT(l, iter);
    case arith_token_DECREMENT: return arith_match_DECREMENT(l, iter);
    case arith_token_INTEGER: return arith_match_INTEGER(l, iter);
    case arith_token_SPACE: return arith_match_SPACE(l, iter);
    case arith_token_NEWLINE: return arith_match_NEWLINE(l, iter);
    case arith_token_CONTROL: return arith_match_CONTROL(l, iter);
    default: return failure;
  }
}
