/* Generated by re2c 3.1 */
// -*-c-*-
#include "arith.lexer.h"
#include <assert.h>
// Definitions first
  

static lexer_match_t arith_match_PLUS(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case 'a': goto re2c3;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c7;
      goto re2c1;
  }
re2c1:
  ++YYCURSOR;
re2c2:
  { goto failure; }
re2c3:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'd': goto re2c4;
    default: goto re2c2;
  }
re2c4:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'd': goto re2c6;
    default: goto re2c5;
  }
re2c5:
  YYCURSOR = YYMARKER;
  goto re2c2;
re2c6:
  ++YYCURSOR;
  { id = arith_token_PLUS; goto match; }
re2c7:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_MINUS(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case 's': goto re2c11;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c15;
      goto re2c9;
  }
re2c9:
  ++YYCURSOR;
re2c10:
  { goto failure; }
re2c11:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'u': goto re2c12;
    default: goto re2c10;
  }
re2c12:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'b': goto re2c14;
    default: goto re2c13;
  }
re2c13:
  YYCURSOR = YYMARKER;
  goto re2c10;
re2c14:
  ++YYCURSOR;
  { id = arith_token_MINUS; goto match; }
re2c15:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_TIMES(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case 'm': goto re2c19;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c23;
      goto re2c17;
  }
re2c17:
  ++YYCURSOR;
re2c18:
  { goto failure; }
re2c19:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'u': goto re2c20;
    default: goto re2c18;
  }
re2c20:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'l': goto re2c22;
    default: goto re2c21;
  }
re2c21:
  YYCURSOR = YYMARKER;
  goto re2c18;
re2c22:
  ++YYCURSOR;
  { id = arith_token_TIMES; goto match; }
re2c23:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_DIVIDE(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case 'd': goto re2c27;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c31;
      goto re2c25;
  }
re2c25:
  ++YYCURSOR;
re2c26:
  { goto failure; }
re2c27:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'i': goto re2c28;
    default: goto re2c26;
  }
re2c28:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'v': goto re2c30;
    default: goto re2c29;
  }
re2c29:
  YYCURSOR = YYMARKER;
  goto re2c26;
re2c30:
  ++YYCURSOR;
  { id = arith_token_DIVIDE; goto match; }
re2c31:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_REMAINDER(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case 'r': goto re2c35;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c39;
      goto re2c33;
  }
re2c33:
  ++YYCURSOR;
re2c34:
  { goto failure; }
re2c35:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'e': goto re2c36;
    default: goto re2c34;
  }
re2c36:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'm': goto re2c38;
    default: goto re2c37;
  }
re2c37:
  YYCURSOR = YYMARKER;
  goto re2c34;
re2c38:
  ++YYCURSOR;
  { id = arith_token_REMAINDER; goto match; }
re2c39:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_INTEGER(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case '-': goto re2c43;
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9': goto re2c44;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c46;
      goto re2c41;
  }
re2c41:
  ++YYCURSOR;
re2c42:
  { goto failure; }
re2c43:
  yych = *++YYCURSOR;
  switch (yych) {
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9': goto re2c44;
    default: goto re2c42;
  }
re2c44:
  yych = *++YYCURSOR;
  switch (yych) {
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9': goto re2c44;
    default: goto re2c45;
  }
re2c45:
  { id = arith_token_INTEGER; goto match; }
re2c46:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_LPAREN(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case '(': goto re2c49;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c50;
      goto re2c48;
  }
re2c48:
  ++YYCURSOR;
  { goto failure; }
re2c49:
  ++YYCURSOR;
  { id = arith_token_LPAREN; goto match; }
re2c50:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_RPAREN(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case ')': goto re2c53;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c54;
      goto re2c52;
  }
re2c52:
  ++YYCURSOR;
  { goto failure; }
re2c53:
  ++YYCURSOR;
  { id = arith_token_RPAREN; goto match; }
re2c54:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_WHITESPACE(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case '\t':
    case '\n':
    case '\v':
    case '\f':
    case '\r':
    case ' ': goto re2c57;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c59;
      goto re2c56;
  }
re2c56:
  ++YYCURSOR;
  { goto failure; }
re2c57:
  yych = *++YYCURSOR;
  switch (yych) {
    case '\t':
    case '\n':
    case '\v':
    case '\f':
    case '\r':
    case ' ': goto re2c57;
    default: goto re2c58;
  }
re2c58:
  { id = arith_token_WHITESPACE; goto match; }
re2c59:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}


lexer_match_t arith_lexer_re2c_sequence_regex_bytes_matching(lexer_t lex,
                                             lexer_iterator_t iter)
{
  (void)lex;
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;

  
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case '\t':
    case '\n':
    case '\v':
    case '\f':
    case '\r':
    case ' ': goto re2c63;
    case '(': goto re2c65;
    case ')': goto re2c66;
    case '-': goto re2c67;
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9': goto re2c68;
    case 'a': goto re2c70;
    case 'd': goto re2c71;
    case 'm': goto re2c72;
    case 'r': goto re2c73;
    case 's': goto re2c74;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c86;
      goto re2c61;
  }
re2c61:
  ++YYCURSOR;
re2c62:
  { id = arith_token_UNKNOWN; goto match; }
re2c63:
  yych = *++YYCURSOR;
  switch (yych) {
    case '\t':
    case '\n':
    case '\v':
    case '\f':
    case '\r':
    case ' ': goto re2c63;
    default: goto re2c64;
  }
re2c64:
  { id = arith_token_WHITESPACE; goto match; }
re2c65:
  ++YYCURSOR;
  { id = arith_token_LPAREN; goto match; }
re2c66:
  ++YYCURSOR;
  { id = arith_token_RPAREN; goto match; }
re2c67:
  yych = *++YYCURSOR;
  switch (yych) {
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9': goto re2c68;
    default: goto re2c62;
  }
re2c68:
  yych = *++YYCURSOR;
  switch (yych) {
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9': goto re2c68;
    default: goto re2c69;
  }
re2c69:
  { id = arith_token_INTEGER; goto match; }
re2c70:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'd': goto re2c75;
    default: goto re2c62;
  }
re2c71:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'i': goto re2c77;
    default: goto re2c62;
  }
re2c72:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'u': goto re2c78;
    default: goto re2c62;
  }
re2c73:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'e': goto re2c79;
    default: goto re2c62;
  }
re2c74:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'u': goto re2c80;
    default: goto re2c62;
  }
re2c75:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'd': goto re2c81;
    default: goto re2c76;
  }
re2c76:
  YYCURSOR = YYMARKER;
  goto re2c62;
re2c77:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'v': goto re2c82;
    default: goto re2c76;
  }
re2c78:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'l': goto re2c83;
    default: goto re2c76;
  }
re2c79:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'm': goto re2c84;
    default: goto re2c76;
  }
re2c80:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'b': goto re2c85;
    default: goto re2c76;
  }
re2c81:
  ++YYCURSOR;
  { id = arith_token_PLUS; goto match; }
re2c82:
  ++YYCURSOR;
  { id = arith_token_DIVIDE; goto match; }
re2c83:
  ++YYCURSOR;
  { id = arith_token_TIMES; goto match; }
re2c84:
  ++YYCURSOR;
  { id = arith_token_REMAINDER; goto match; }
re2c85:
  ++YYCURSOR;
  { id = arith_token_MINUS; goto match; }
re2c86:
  { goto failure; }
}

  // re2c finish

  

  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:
  assert(id == arith_token_count);
  id = arith_token_UNKNOWN;
  YYCURSOR = iter.cursor;

match:;
  size_t width = YYCURSOR - iter.cursor;
  return (lexer_match_t){
      .regex_id = (size_t)id,
      .bytes_count = width,
  };
}


lexer_token_t arith_lexer_re2c_iterator_step(lexer_t lex,
                                             lexer_iterator_t *iter)
{
  lexer_match_t res = arith_lexer_re2c_sequence_regex_bytes_matching(lex, *iter);
  lexer_token_t result = {
    .id = res.regex_id,
    .value = iter->cursor,
    .width = res.bytes_count,
  };
  iter->cursor += res.bytes_count;
  return result;
}


lexer_match_t arith_lexer_re2c_single_regex_bytes_matching(lexer_t l, size_t regex_idx, lexer_iterator_t iter)
{
  lexer_match_t failure = (lexer_match_t) { .regex_id = arith_token_count, .bytes_count = 0, };
  if (lexer_iterator_t_empty(iter))
  {
    return failure;
  }
  switch(regex_idx)
  {
    case arith_token_UNKNOWN: return (lexer_match_t) { .regex_id = arith_token_UNKNOWN, .bytes_count = 1,}; 
    case arith_token_PLUS: return arith_match_PLUS(l, iter);
    case arith_token_MINUS: return arith_match_MINUS(l, iter);
    case arith_token_TIMES: return arith_match_TIMES(l, iter);
    case arith_token_DIVIDE: return arith_match_DIVIDE(l, iter);
    case arith_token_REMAINDER: return arith_match_REMAINDER(l, iter);
    case arith_token_INTEGER: return arith_match_INTEGER(l, iter);
    case arith_token_LPAREN: return arith_match_LPAREN(l, iter);
    case arith_token_RPAREN: return arith_match_RPAREN(l, iter);
    case arith_token_WHITESPACE: return arith_match_WHITESPACE(l, iter);
    default: return failure;
  }
}
