/* Generated by re2c 3.1 */
// -*-c-*-
#include "arith.lexer.h"
#include <assert.h>
// Definitions first
  

static lexer_match_t arith_match_PLUS(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case 'a': goto re2c3;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c7;
      goto re2c1;
  }
re2c1:
  ++YYCURSOR;
re2c2:
  { goto failure; }
re2c3:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'd': goto re2c4;
    default: goto re2c2;
  }
re2c4:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'd': goto re2c6;
    default: goto re2c5;
  }
re2c5:
  YYCURSOR = YYMARKER;
  goto re2c2;
re2c6:
  ++YYCURSOR;
  { id = arith_token_PLUS; goto match; }
re2c7:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_MINUS(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case 's': goto re2c11;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c15;
      goto re2c9;
  }
re2c9:
  ++YYCURSOR;
re2c10:
  { goto failure; }
re2c11:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'u': goto re2c12;
    default: goto re2c10;
  }
re2c12:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'b': goto re2c14;
    default: goto re2c13;
  }
re2c13:
  YYCURSOR = YYMARKER;
  goto re2c10;
re2c14:
  ++YYCURSOR;
  { id = arith_token_MINUS; goto match; }
re2c15:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_TIMES(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case 'm': goto re2c19;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c23;
      goto re2c17;
  }
re2c17:
  ++YYCURSOR;
re2c18:
  { goto failure; }
re2c19:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'u': goto re2c20;
    default: goto re2c18;
  }
re2c20:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'l': goto re2c22;
    default: goto re2c21;
  }
re2c21:
  YYCURSOR = YYMARKER;
  goto re2c18;
re2c22:
  ++YYCURSOR;
  { id = arith_token_TIMES; goto match; }
re2c23:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_DIVIDE(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case 'd': goto re2c27;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c31;
      goto re2c25;
  }
re2c25:
  ++YYCURSOR;
re2c26:
  { goto failure; }
re2c27:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'i': goto re2c28;
    default: goto re2c26;
  }
re2c28:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'v': goto re2c30;
    default: goto re2c29;
  }
re2c29:
  YYCURSOR = YYMARKER;
  goto re2c26;
re2c30:
  ++YYCURSOR;
  { id = arith_token_DIVIDE; goto match; }
re2c31:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_REMAINDER(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case 'r': goto re2c35;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c39;
      goto re2c33;
  }
re2c33:
  ++YYCURSOR;
re2c34:
  { goto failure; }
re2c35:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'e': goto re2c36;
    default: goto re2c34;
  }
re2c36:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'm': goto re2c38;
    default: goto re2c37;
  }
re2c37:
  YYCURSOR = YYMARKER;
  goto re2c34;
re2c38:
  ++YYCURSOR;
  { id = arith_token_REMAINDER; goto match; }
re2c39:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_BITOR(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case 'o': goto re2c43;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c45;
      goto re2c41;
  }
re2c41:
  ++YYCURSOR;
re2c42:
  { goto failure; }
re2c43:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'r': goto re2c44;
    default: goto re2c42;
  }
re2c44:
  ++YYCURSOR;
  { id = arith_token_BITOR; goto match; }
re2c45:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_BITAND(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case 'a': goto re2c49;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c53;
      goto re2c47;
  }
re2c47:
  ++YYCURSOR;
re2c48:
  { goto failure; }
re2c49:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'n': goto re2c50;
    default: goto re2c48;
  }
re2c50:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'd': goto re2c52;
    default: goto re2c51;
  }
re2c51:
  YYCURSOR = YYMARKER;
  goto re2c48;
re2c52:
  ++YYCURSOR;
  { id = arith_token_BITAND; goto match; }
re2c53:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_BITXOR(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case 'x': goto re2c57;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c61;
      goto re2c55;
  }
re2c55:
  ++YYCURSOR;
re2c56:
  { goto failure; }
re2c57:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'o': goto re2c58;
    default: goto re2c56;
  }
re2c58:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'r': goto re2c60;
    default: goto re2c59;
  }
re2c59:
  YYCURSOR = YYMARKER;
  goto re2c56;
re2c60:
  ++YYCURSOR;
  { id = arith_token_BITXOR; goto match; }
re2c61:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_ABSOLUTE(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case 'a': goto re2c65;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c69;
      goto re2c63;
  }
re2c63:
  ++YYCURSOR;
re2c64:
  { goto failure; }
re2c65:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'b': goto re2c66;
    default: goto re2c64;
  }
re2c66:
  yych = *++YYCURSOR;
  switch (yych) {
    case 's': goto re2c68;
    default: goto re2c67;
  }
re2c67:
  YYCURSOR = YYMARKER;
  goto re2c64;
re2c68:
  ++YYCURSOR;
  { id = arith_token_ABSOLUTE; goto match; }
re2c69:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_NEGATE(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case 'n': goto re2c73;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c77;
      goto re2c71;
  }
re2c71:
  ++YYCURSOR;
re2c72:
  { goto failure; }
re2c73:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'e': goto re2c74;
    default: goto re2c72;
  }
re2c74:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'g': goto re2c76;
    default: goto re2c75;
  }
re2c75:
  YYCURSOR = YYMARKER;
  goto re2c72;
re2c76:
  ++YYCURSOR;
  { id = arith_token_NEGATE; goto match; }
re2c77:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_INCREMENT(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case 'i': goto re2c81;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c86;
      goto re2c79;
  }
re2c79:
  ++YYCURSOR;
re2c80:
  { goto failure; }
re2c81:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'n': goto re2c82;
    default: goto re2c80;
  }
re2c82:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'c': goto re2c84;
    default: goto re2c83;
  }
re2c83:
  YYCURSOR = YYMARKER;
  goto re2c80;
re2c84:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'r': goto re2c85;
    default: goto re2c83;
  }
re2c85:
  ++YYCURSOR;
  { id = arith_token_INCREMENT; goto match; }
re2c86:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_DECREMENT(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case 'd': goto re2c90;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c95;
      goto re2c88;
  }
re2c88:
  ++YYCURSOR;
re2c89:
  { goto failure; }
re2c90:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'e': goto re2c91;
    default: goto re2c89;
  }
re2c91:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'c': goto re2c93;
    default: goto re2c92;
  }
re2c92:
  YYCURSOR = YYMARKER;
  goto re2c89;
re2c93:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'r': goto re2c94;
    default: goto re2c92;
  }
re2c94:
  ++YYCURSOR;
  { id = arith_token_DECREMENT; goto match; }
re2c95:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_INTEGER(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case '-': goto re2c99;
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9': goto re2c100;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c102;
      goto re2c97;
  }
re2c97:
  ++YYCURSOR;
re2c98:
  { goto failure; }
re2c99:
  yych = *++YYCURSOR;
  switch (yych) {
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9': goto re2c100;
    default: goto re2c98;
  }
re2c100:
  yych = *++YYCURSOR;
  switch (yych) {
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9': goto re2c100;
    default: goto re2c101;
  }
re2c101:
  { id = arith_token_INTEGER; goto match; }
re2c102:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_SPACE(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case ' ': goto re2c105;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c106;
      goto re2c104;
  }
re2c104:
  ++YYCURSOR;
  { goto failure; }
re2c105:
  ++YYCURSOR;
  { id = arith_token_SPACE; goto match; }
re2c106:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_NEWLINE(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case '\n': goto re2c109;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c110;
      goto re2c108;
  }
re2c108:
  ++YYCURSOR;
  { goto failure; }
re2c109:
  ++YYCURSOR;
  { id = arith_token_NEWLINE; goto match; }
re2c110:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}

static lexer_match_t arith_match_CONTROL(lexer_t l, lexer_iterator_t iter)
{
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;
    
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case '!':
    case '#':
    case '$':
    case '%':
    case '&':
    case '@':
    case 'A':
    case 'B':
    case 'C':
    case 'D':
    case 'E':
    case 'F':
    case 'G':
    case 'H':
    case 'I':
    case 'J':
    case 'K':
    case 'L':
    case 'M':
    case 'N':
    case 'O':
    case 'P':
    case 'Q':
    case 'R':
    case 'S':
    case 'T':
    case 'U':
    case 'V':
    case 'W':
    case 'X':
    case 'Y':
    case 'Z': goto re2c113;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c115;
      goto re2c112;
  }
re2c112:
  ++YYCURSOR;
  { goto failure; }
re2c113:
  yych = *++YYCURSOR;
  switch (yych) {
    case '!':
    case '#':
    case '$':
    case '%':
    case '&':
    case '@':
    case 'A':
    case 'B':
    case 'C':
    case 'D':
    case 'E':
    case 'F':
    case 'G':
    case 'H':
    case 'I':
    case 'J':
    case 'K':
    case 'L':
    case 'M':
    case 'N':
    case 'O':
    case 'P':
    case 'Q':
    case 'R':
    case 'S':
    case 'T':
    case 'U':
    case 'V':
    case 'W':
    case 'X':
    case 'Y':
    case 'Z': goto re2c113;
    default: goto re2c114;
  }
re2c114:
  { id = arith_token_CONTROL; goto match; }
re2c115:
  { goto failure; }
}

  // re2c finish

  


  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:  
  assert(id == arith_token_count);
  YYCURSOR = iter.cursor;

match:;

  return (lexer_match_t)
  {
    .regex_id = id,
    .bytes_count = YYCURSOR - iter.cursor,
  };

}


lexer_match_t arith_lexer_re2c_sequence_regex_bytes_matching(lexer_t lex,
                                             lexer_iterator_t iter)
{
  (void)lex;
  const char* YYCURSOR = iter.cursor;
  const char* YYLIMIT = iter.end;

  
  const char* YYMARKER; (void)YYMARKER;

  enum arith_token id = arith_token_count;

  // re2c begin
  
{
  char yych;
  yych = *YYCURSOR;
  switch (yych) {
    case '\n': goto re2c119;
    case ' ': goto re2c120;
    case '!':
    case '#':
    case '$':
    case '%':
    case '&':
    case '@':
    case 'A':
    case 'B':
    case 'C':
    case 'D':
    case 'E':
    case 'F':
    case 'G':
    case 'H':
    case 'I':
    case 'J':
    case 'K':
    case 'L':
    case 'M':
    case 'N':
    case 'O':
    case 'P':
    case 'Q':
    case 'R':
    case 'S':
    case 'T':
    case 'U':
    case 'V':
    case 'W':
    case 'X':
    case 'Y':
    case 'Z': goto re2c121;
    case '-': goto re2c123;
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9': goto re2c124;
    case 'a': goto re2c126;
    case 'd': goto re2c127;
    case 'i': goto re2c128;
    case 'm': goto re2c129;
    case 'n': goto re2c130;
    case 'o': goto re2c131;
    case 'r': goto re2c132;
    case 's': goto re2c133;
    case 'x': goto re2c134;
    default:
      if (YYLIMIT <= YYCURSOR) goto re2c161;
      goto re2c117;
  }
re2c117:
  ++YYCURSOR;
re2c118:
  { id = arith_token_UNKNOWN; goto match; }
re2c119:
  ++YYCURSOR;
  { id = arith_token_NEWLINE; goto match; }
re2c120:
  ++YYCURSOR;
  { id = arith_token_SPACE; goto match; }
re2c121:
  yych = *++YYCURSOR;
  switch (yych) {
    case '!':
    case '#':
    case '$':
    case '%':
    case '&':
    case '@':
    case 'A':
    case 'B':
    case 'C':
    case 'D':
    case 'E':
    case 'F':
    case 'G':
    case 'H':
    case 'I':
    case 'J':
    case 'K':
    case 'L':
    case 'M':
    case 'N':
    case 'O':
    case 'P':
    case 'Q':
    case 'R':
    case 'S':
    case 'T':
    case 'U':
    case 'V':
    case 'W':
    case 'X':
    case 'Y':
    case 'Z': goto re2c121;
    default: goto re2c122;
  }
re2c122:
  { id = arith_token_CONTROL; goto match; }
re2c123:
  yych = *++YYCURSOR;
  switch (yych) {
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9': goto re2c124;
    default: goto re2c118;
  }
re2c124:
  yych = *++YYCURSOR;
  switch (yych) {
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9': goto re2c124;
    default: goto re2c125;
  }
re2c125:
  { id = arith_token_INTEGER; goto match; }
re2c126:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'b': goto re2c135;
    case 'd': goto re2c137;
    case 'n': goto re2c138;
    default: goto re2c118;
  }
re2c127:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'e': goto re2c139;
    case 'i': goto re2c140;
    default: goto re2c118;
  }
re2c128:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'n': goto re2c141;
    default: goto re2c118;
  }
re2c129:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'u': goto re2c142;
    default: goto re2c118;
  }
re2c130:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'e': goto re2c143;
    default: goto re2c118;
  }
re2c131:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'r': goto re2c144;
    default: goto re2c118;
  }
re2c132:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'e': goto re2c145;
    default: goto re2c118;
  }
re2c133:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'u': goto re2c146;
    default: goto re2c118;
  }
re2c134:
  yych = *(YYMARKER = ++YYCURSOR);
  switch (yych) {
    case 'o': goto re2c147;
    default: goto re2c118;
  }
re2c135:
  yych = *++YYCURSOR;
  switch (yych) {
    case 's': goto re2c148;
    default: goto re2c136;
  }
re2c136:
  YYCURSOR = YYMARKER;
  goto re2c118;
re2c137:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'd': goto re2c149;
    default: goto re2c136;
  }
re2c138:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'd': goto re2c150;
    default: goto re2c136;
  }
re2c139:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'c': goto re2c151;
    default: goto re2c136;
  }
re2c140:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'v': goto re2c152;
    default: goto re2c136;
  }
re2c141:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'c': goto re2c153;
    default: goto re2c136;
  }
re2c142:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'l': goto re2c154;
    default: goto re2c136;
  }
re2c143:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'g': goto re2c155;
    default: goto re2c136;
  }
re2c144:
  ++YYCURSOR;
  { id = arith_token_BITOR; goto match; }
re2c145:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'm': goto re2c156;
    default: goto re2c136;
  }
re2c146:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'b': goto re2c157;
    default: goto re2c136;
  }
re2c147:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'r': goto re2c158;
    default: goto re2c136;
  }
re2c148:
  ++YYCURSOR;
  { id = arith_token_ABSOLUTE; goto match; }
re2c149:
  ++YYCURSOR;
  { id = arith_token_PLUS; goto match; }
re2c150:
  ++YYCURSOR;
  { id = arith_token_BITAND; goto match; }
re2c151:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'r': goto re2c159;
    default: goto re2c136;
  }
re2c152:
  ++YYCURSOR;
  { id = arith_token_DIVIDE; goto match; }
re2c153:
  yych = *++YYCURSOR;
  switch (yych) {
    case 'r': goto re2c160;
    default: goto re2c136;
  }
re2c154:
  ++YYCURSOR;
  { id = arith_token_TIMES; goto match; }
re2c155:
  ++YYCURSOR;
  { id = arith_token_NEGATE; goto match; }
re2c156:
  ++YYCURSOR;
  { id = arith_token_REMAINDER; goto match; }
re2c157:
  ++YYCURSOR;
  { id = arith_token_MINUS; goto match; }
re2c158:
  ++YYCURSOR;
  { id = arith_token_BITXOR; goto match; }
re2c159:
  ++YYCURSOR;
  { id = arith_token_DECREMENT; goto match; }
re2c160:
  ++YYCURSOR;
  { id = arith_token_INCREMENT; goto match; }
re2c161:
  { goto failure; }
}

  // re2c finish

  

  // If we got here with none matching id is still count but YYCURSOR has
  // probably been mutated. Set up the variables to indicate failure.
failure:
  assert(id == arith_token_count);
  id = arith_token_UNKNOWN;
  YYCURSOR = iter.cursor;

match:;
  size_t width = YYCURSOR - iter.cursor;
  return (lexer_match_t){
      .regex_id = (size_t)id,
      .bytes_count = width,
  };
}


lexer_token_t arith_lexer_re2c_iterator_step(lexer_t lex,
                                             lexer_iterator_t *iter)
{
  lexer_match_t res = arith_lexer_re2c_sequence_regex_bytes_matching(lex, *iter);
  lexer_token_t result = {
    .id = res.regex_id,
    .value = iter->cursor,
    .width = res.bytes_count,
  };
  iter->cursor += res.bytes_count;
  return result;
}


lexer_match_t arith_lexer_re2c_single_regex_bytes_matching(lexer_t l, size_t regex_idx, lexer_iterator_t iter)
{
  lexer_match_t failure = (lexer_match_t) { .regex_id = arith_token_count, .bytes_count = 0, };
  if (lexer_iterator_t_empty(iter))
  {
    return failure;
  }
  switch(regex_idx)
  {
    case arith_token_UNKNOWN: return (lexer_match_t) { .regex_id = arith_token_UNKNOWN, .bytes_count = 1,}; 
    case arith_token_PLUS: return arith_match_PLUS(l, iter);
    case arith_token_MINUS: return arith_match_MINUS(l, iter);
    case arith_token_TIMES: return arith_match_TIMES(l, iter);
    case arith_token_DIVIDE: return arith_match_DIVIDE(l, iter);
    case arith_token_REMAINDER: return arith_match_REMAINDER(l, iter);
    case arith_token_BITOR: return arith_match_BITOR(l, iter);
    case arith_token_BITAND: return arith_match_BITAND(l, iter);
    case arith_token_BITXOR: return arith_match_BITXOR(l, iter);
    case arith_token_ABSOLUTE: return arith_match_ABSOLUTE(l, iter);
    case arith_token_NEGATE: return arith_match_NEGATE(l, iter);
    case arith_token_INCREMENT: return arith_match_INCREMENT(l, iter);
    case arith_token_DECREMENT: return arith_match_DECREMENT(l, iter);
    case arith_token_INTEGER: return arith_match_INTEGER(l, iter);
    case arith_token_SPACE: return arith_match_SPACE(l, iter);
    case arith_token_NEWLINE: return arith_match_NEWLINE(l, iter);
    case arith_token_CONTROL: return arith_match_CONTROL(l, iter);
    default: return failure;
  }
}
